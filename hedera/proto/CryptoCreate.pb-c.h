/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: CryptoCreate.proto */

#ifndef PROTOBUF_C_CryptoCreate_2eproto__INCLUDED
#define PROTOBUF_C_CryptoCreate_2eproto__INCLUDED

#include "protobuf-c.h"

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1003000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003002 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif

#include "BasicTypes.pb-c.h"
#include "Duration.pb-c.h"

typedef struct _Proto__CryptoCreateTransactionBody Proto__CryptoCreateTransactionBody;


/* --- enums --- */


/* --- messages --- */

/*
 * Create a new account. After the account is created, the AccountID for it is in the receipt, or can be retrieved with a GetByKey query, or by asking for a Record of the transaction to be created, and retrieving that. The account can then automatically generate records for large transfers into it or out of it, which each last for 25 hours. Records are generated for any transfer that exceeds the thresholds given here. This account is charged cryptocurrency for each record generated, so the thresholds are useful for limiting Record generation to happen only for large transactions. The Key field is the key used to sign transactions for this account. If the account has receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this account's key, both for transfers in and out. If it is false, then only transfers out have to be signed by it. When the account is created, the payer account is charged enough hbars so that the new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration time, the new account will then be automatically charged to renew for another autoRenewPeriod seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are used to extend its expiration as long as possible. If it is has a zero balance when it expires, then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired is false, then the transaction does not have to be signed by the keys in the keys field. If it is true, then it must be signed by them, in addition to the keys of the payer account.
 * An entity (account, file, or smart contract instance) must be created in a particular realm. If the realmID is left null, then a new realm will be created with the given admin key. If a new realm has a null adminKey, then anyone can create/modify/delete entities in that realm. But if an admin key is given, then any transaction to create/modify/delete an entity in that realm must be signed by that key, though anyone can still call functions on smart contract instances that exist in that realm. A realm ceases to exist when everything within it has expired and no longer exists.
 * The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0 and realm 0, with a null key. Future versions of the API will support multiple realms and multiple shards.
 */
struct  _Proto__CryptoCreateTransactionBody
{
  ProtobufCMessage base;
  /*
   * The key that must sign each transfer out of the account. If receiverSigRequired is true, then it must also sign any transfer into the account.
   */
  Proto__Key *key;
  /*
   * The initial number of tinybars to put into the account
   */
  uint64_t initialbalance;
  /*
   * ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an invalid account, or is an account that isn't a node, then this account is automatically proxy staked to a node chosen by the network, but without earning payments. If the proxyAccountID account refuses to accept proxy staking , or if it is not currently running a node, then it will behave as if proxyAccountID was null.
   */
  Proto__AccountID *proxyaccountid;
  /*
   * The threshold amount (in tinybars) for which an account record is created for any send/withdraw transaction
   */
  uint64_t sendrecordthreshold;
  /*
   * The threshold amount (in tinybars) for which an account record is created for any receive/deposit transaction
   */
  uint64_t receiverecordthreshold;
  /*
   * If true, this account's key must sign any transaction depositing into this account (in addition to all withdrawals)
   */
  protobuf_c_boolean receiversigrequired;
  /*
   * The account is charged to extend its expiration date every this many seconds. If it doesn't have enough balance, it extends as long as possible. If it is empty when it expires, then it is deleted.
   */
  Proto__Duration *autorenewperiod;
  /*
   * The shard in which this account is created
   */
  Proto__ShardID *shardid;
  /*
   * The realm in which this account is created (leave this null to create a new realm)
   */
  Proto__RealmID *realmid;
  /*
   * If realmID is null, then this the admin key for the new realm that will be created
   */
  Proto__Key *newrealmadminkey;
};
#define PROTO__CRYPTO_CREATE_TRANSACTION_BODY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&proto__crypto_create_transaction_body__descriptor) \
    , NULL, 0, NULL, 0, 0, 0, NULL, NULL, NULL, NULL }


/* Proto__CryptoCreateTransactionBody methods */
void   proto__crypto_create_transaction_body__init
                     (Proto__CryptoCreateTransactionBody         *message);
size_t proto__crypto_create_transaction_body__get_packed_size
                     (const Proto__CryptoCreateTransactionBody   *message);
size_t proto__crypto_create_transaction_body__pack
                     (const Proto__CryptoCreateTransactionBody   *message,
                      uint8_t             *out);
size_t proto__crypto_create_transaction_body__pack_to_buffer
                     (const Proto__CryptoCreateTransactionBody   *message,
                      ProtobufCBuffer     *buffer);
Proto__CryptoCreateTransactionBody *
       proto__crypto_create_transaction_body__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   proto__crypto_create_transaction_body__free_unpacked
                     (Proto__CryptoCreateTransactionBody *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Proto__CryptoCreateTransactionBody_Closure)
                 (const Proto__CryptoCreateTransactionBody *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor proto__crypto_create_transaction_body__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_CryptoCreate_2eproto__INCLUDED */
